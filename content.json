[{"title":"Windows10安装QT6.2和VS2019插件踩坑记录","date":"2021-10-13T11:48:41.000Z","path":"2021/10/13/安装QT和VS插件踩坑记录/","text":"今天学习安装了Qt6.2，并在vs里安装qt插件，完成hello world!的Qt项目。中间遇到了不少的坑，在此记录一下，为以后可能再次安装时提供一点解决思路。 安装 Qt 6.2我直接到官网选择开源(open source)版本下载，这里需要用邮箱先注册一个账号（里面的必填公司我写的暂无）。然后下载好在线安装的执行文件，可以开始愉快的在线安装了。 国内在线安装想要直连官方的下载源，可以说是基本没下载速度了。因此，最好使用国内的几个镜像进行在线下载和安装。这里列几个网上一搜就有的镜像源： 中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/ 清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/ 北京理工大学：https://mirrors.bit.edu.cn/qtproject/ 中国互联网络信息中心：https://mirrors.cnnic.cn/qt/ 具体使用方法： 上图界面内点击左下角那个按钮，进入网络和源配置界面。 先把Network的选到No proxy，然后到Repositories配置页面，在user defined repositories里添加国内镜像源。 需要注意的是，镜像源地址需要加上/online/qtsdkrepository/default_install/，或者qtsdkrepository文件夹下的对应平台的源才能test通。 踩坑记录（1）在这里我最开始使用的清华源，但是从中午一直下载到下午，一直卡在10%左右，然后去镜像网站看到qt源正在同步中(syncing)，推测是这个原因导致部分文件无法下载。换源后可下载，值得注意的是显示进度到35%时就已经下载完成，之后都是文件解压和安装。 注：Qt自定义安装需要按需选择部分内容，本人主要想使用VS2019进行Qt开发，故选择和VS2019配套的安装内容。 安装VS2019的Qt插件踩坑记录（2）VS插件管理里直接搜索Qt就有，但是国内直连懂得都懂。这时候还是换国内镜像源下载，位置在../archive/vsaddin/文件夹下，先择最新的版本下载，关掉VS运行下载的.vsix文件，自动安装。 VS2019创建和运行Qt项目Hello world!踩坑记录（3）创建项目就无法创建，报错没有指定Qt版本，遇到这种情况就需要先去VS插件管理里，在Qt的选项里，手动将Qt安装路径下对应MSVC版本文件夹下的qmake.exe加到版本中。 踩坑记录（4）这下我们就能开熏地创建Qt项目了，建好我就直接一个不讲武德地F5，然后报了几百个错。 别急，先去项目属性里把c++语言标准改成17或以上，这时运行一下，剩了两个错，还行。 最后两个错所在行报错原因是当前__cplusplus值比201703L小，而搜了一下这个值地官方解释和解决方法，解决起来很容易。 然后运行很完美，就是啥组件都没有，没有hello world! 踩坑记录（5）为了加上hello world!，到Qt表单地.ui文件里，然后尴尬的闪退报错打不开。 解决方法：右键.ui文件，选择打开方式，然后手动选择Qt安装文件夹下的../msvc2019_64/bin的designer.exe打开就可以了。 小结最后可喜可贺，一个hello world!的Qt项目就完成了。","tags":[{"name":"c++","slug":"c","permalink":"https://myharu.github.io/tags/c/"},{"name":"Qt 6.2","slug":"Qt-6-2","permalink":"https://myharu.github.io/tags/Qt-6-2/"},{"name":"visual studio","slug":"visual-studio","permalink":"https://myharu.github.io/tags/visual-studio/"}]},{"title":"SSM框架（后端）——（五）项目自定义封装类","date":"2020-09-17T14:00:35.000Z","path":"2020/09/17/SSM框架（后端）——（五）自定义封装类/","text":"后端项目controller层返回封装类作为前后端分离的项目，前端会调用后端Controller层的接口进行页面逻辑的实现、调试和测试 引入返回类型，为项目Controller层提供统一且合理的返回对象正在努力更新中…","tags":[{"name":"ssm","slug":"ssm","permalink":"https://myharu.github.io/tags/ssm/"},{"name":"自定义封装类","slug":"自定义封装类","permalink":"https://myharu.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B0%81%E8%A3%85%E7%B1%BB/"}]},{"title":"SSM框架（后端）——（四）集成和配置mybatis-plus","date":"2020-09-15T11:47:34.000Z","path":"2020/09/15/SSM框架（后端）——（四）集成和配置mybatis-plus/","text":"Mybatis-plus简介MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 配置Mybatis-plus添加依赖123456789101112&lt;!-- mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.starter.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 其中，引入了包，lombok是非常实用的一个工具，能够帮助开发人员省去实体类繁琐的setter和getter等方法。具体的介绍可以进入 projectlombok官网 github项目地址 进行学习。 application.properties中配置Mybatis-plusMyBatis-Plus 的配置异常的简单，一下对本项目需要的功能做出配置。详细配置请参考配置一文。 123456789#Mybatis-plus配置#控制台日志输出mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl#命名策略mybatis-plus.configuration.map-underscore-to-camel-case=true#逻辑删除mybatis-plus.global-config.db-config.logic-delete-field=deletedmybatis-plus.global-config.db-config.logic-delete-value=1mybatis-plus.global-config.db-config.logic-not-delete-value=0 Mybatis-plus分页插件Mybatis-plus提供了数据库分页查询的插件，从分页插件用法示例中，使用Spring Boot方式配置。构建MybatisPlusConfig类，并进行如下部署：（Gitee示例） 1234567891011121314@Configuration@MapperScan(basePackages = &#123;\"com.ssm.ssmproject.**.mapper\"&#125;)public class MybatisPlusConfig &#123; /** * 3.4.0分页插件写法，参考gitee示例中的写法 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; Mybatis-plus自动填充功能配置自动填充功能参考自动填充功能 注解填充字段 @TableField(.. fill = FieldFill.INSERT) [代码生成器](# Mybatis-plus 代码生成器)策略部分也可以配置！ 123456789public class User &#123; // 注意！这里需要标记为填充字段 // 请参考代码生成器中配置策略 @TableField(.. fill = FieldFill.INSERT) private String fillField; ....&#125; 自定义实现类 MyMetaObjectHandler，以下是针对本项目需要配置自动填充的字段： 123456789101112131415161718@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.strictInsertFill(metaObject, \"createdBy\", Long.class, 123L); this.strictInsertFill(metaObject, \"createdAt\", LocalDateTime.class, LocalDateTime.now()); this.strictInsertFill(metaObject, \"updatedBy\", Long.class, 123L); this.strictInsertFill(metaObject, \"updatedAt\", LocalDateTime.class, LocalDateTime.now()); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.strictUpdateFill(metaObject, \"updatedBy\", Long.class, Long.getLong(\"123\")); this.strictUpdateFill(metaObject, \"updatedAt\", LocalDateTime.class, LocalDateTime.now()); &#125;&#125; 引入fastJson解决LocalDateTime类型转换为DateTime以上已经完成了自动填充功能的基本配置，大部分字段都能系统自动填充入数据库表。但是上面填充数据库DateTime类型的时间字段时，Spring Boot项目内存储的类型为LocalDateTime，需要进行类型转换。而LocalDateTime的toString()方法： 1234@Overridepublic String toString() &#123; return date.toString() + 'T' + time.toString();&#125; 这就导致存入数据库的具体数据格式为’YYYY-MM-DDThh-mm-ss‘不符合DateTime的’YYYY-MM-DD hh-mm-ss‘格式。为了解决这个问题，引入fastJson包。 fastJson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到Java Bean。 配置依赖 123456&lt;!-- fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt;&lt;/dependency&gt; 为实体类时间类型的属性添加注释@JsonFormat（下面的其他注释由生成器自动生成） 1234567891011class User&#123; ... @ApiModelProperty(value = \"创建时间\") @TableField(fill = FieldFill.INSERT) @JsonFormat(pattern = \"YYYY-MM-DD hh:mm:ss\") private LocalDateTime createdAt; ...&#125; Mybatis-plus 代码生成器AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 为项目方便，在项目test模块下新建CodeGenerator类，参考代码生成器配置构建的代码生成器如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class CodeGenerator &#123; @Test public void codeGenerator() &#123; //模块名称 String moduleName = \"system\"; // 1、创建代码生成器 AutoGenerator autoGenerator = new AutoGenerator(); // 2、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\");//生成文件的输出目录 gc.setAuthor(\"jinsei\");//开发人员 gc.setOpen(false); //是否打开输出目录 gc.setFileOverride(false); //重新生成时，是否覆盖已有文件 gc.setServiceName(\"%sService\");//service命名方式，默认生成I**Service gc.setIdType(IdType.AUTO); //指定生成的主键的ID类型 gc.setSwagger2(true);//开启Swagger2模式 autoGenerator.setGlobalConfig(gc); // 3、数据源配置，通过该配置，指定需要生成代码的具体数据库 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=GMT%2B8&amp;allowMultiQueries=true\");//驱动连接的URL dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");//驱动名称 dsc.setUsername(\"root\");//数据库连接用户名 dsc.setPassword(\"root\");//数据库连接密码 dsc.setDbType(DbType.MYSQL);//数据库类型 autoGenerator.setDataSource(dsc); // 4、包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(moduleName); //父包模块名 pc.setParent(\"com.ssm.ssmproject\");//父包名。如果为空，将下面子包名必须写全部， 否则就只需写子包名 pc.setController(\"controller\");//Controller包名 pc.setEntity(\"entity\");//Entity包名 pc.setService(\"service\");//Service包名 pc.setMapper(\"mapper\");//Mapper包名 autoGenerator.setPackageInfo(pc); // 5、自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; // 如果模板引擎是 freemarker // String templatePath = \"/templates/mapper.xml.ftl\"; // 如果模板引擎是 velocity String templatePath = \"/templates/mapper.xml.vm\"; // 自定义输出配置(配置xml位置) List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) &#123; @Override public String outputFile(TableInfo tableInfo) &#123; // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName() + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; &#125; &#125;); cfg.setFileOutConfigList(focList); autoGenerator.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); // 去掉了xml的默认配置，避免在默认位置生成重复的mapper.xml templateConfig.setXml(null); autoGenerator.setTemplate(templateConfig); // 6、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"user\");//设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setTablePrefix(pc.getModuleName() + \"_\");//设置表前缀 strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setEntityLombokModel(true); // 是否为lombok模型 strategy.setLogicDeleteFieldName(\"deleted\");//逻辑删除属性名称 strategy.setEntityBooleanColumnRemoveIsPrefix(true);//Boolean类型字段是否移除is前缀 //自动填充 TableFill createdBy = new TableFill(\"created_by\", FieldFill.INSERT); TableFill createdAt = new TableFill(\"created_at\", FieldFill.INSERT); TableFill updatedBy = new TableFill(\"updated_by\", FieldFill.INSERT_UPDATE); TableFill updatedAt = new TableFill(\"updated_at\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(createdBy); tableFills.add(createdAt); tableFills.add(updatedBy); tableFills.add(updatedAt); strategy.setTableFillList(tableFills); strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 autoGenerator.setStrategy(strategy); // 7、执行 autoGenerator.execute(); &#125; 代码生成器的配置将项目所需的Mybatis-plus功能全部配置进去，配置完成后，运行这个测试方法将在项目中指定位置创建数据库User表对应的 Entity、Mapper、Mapper XML、Service、Controller 模块文件。 至此，在项目中的Mybatis-plus就配置完成了。今后项目的后端功能实现流程： 123graph LRA(构建数据库表结构)--&gt;B(生成器生成对应各层接口和类文件) B--&gt;C(根据编写Mapper,Service,Controller层接口) 牛刀小试 至此，SpringBoot项目中Mybatis-plus基础配置完成。针对之前设计的User表运行代码生成器，就可得到各层的文件。按照引入fastJson解决LocalDateTime类型转换为DateTime，对User实体类中的对应属性添加注释。接下来，就可以在Service层和Controller层进行功能的实现了。本小节中，主要演示如何将数据库的CRUD操作通过Mybatis-plus与后端联系起来。 功能需求： 用户的新增（无任何校验） 用户信息修改 用户信息查询（按照id） 用户的删除（按照id） 注：为符合JavaBean的规范和约定，项目中会用DTO(Data Transfer Object)、VO(View Object)等对象进行数据操作。 用户新增添加UserAddDto类在Entity包中新建dto包，并为User实体类新建UserAddDto类，按照用户实际需要的输入添加属性，如下： 1234567891011121314151617181920package com.ssm.ssmproject.system.entity.dto;@Data@ApiModel(value = \"UserAddDto对象\", description = \"用户新增Dto\")public class UserAddDto implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = \"用户名\") private String name; @ApiModelProperty(value = \"用户账号\") private String account; @ApiModelProperty(value = \"用户密码\") private String password; @ApiModelProperty(value = \"手机号\") private String tel;&#125; 其中，该类和User类拥有的属性不同，该类的属性应当是业务逻辑中用户使用添加操作时，需要输入的属性，而其他User类中的属性是默认的或自动插入的。 Service层添加业务逻辑在UserService接口中添加方法： 123456789101112package com.ssm.ssmproject.system.service;public interface UserService extends IService&lt;User&gt; &#123; /** * 新增用户 * @param dto * @return */ Boolean add(UserAddDto dto);&#125; 在UserServiceImpl类中实现该方法的具体逻辑： 12345678910111213package com.ssm.ssmproject.system.service.impl;@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123; @Override public Boolean add(UserAddDto dto)&#123; User user = new User(); BeanUtils.copyProperties(dto,user); return baseMapper.insert(user) &gt; 0; &#125;&#125; Controller层实现接口123456789101112131415161718192021222324package com.ssm.ssmproject.system.controller;@RestController@RequestMapping(\"/system/user\")@Api(tags = \"用户管理层\")public class UserController &#123; private UserService userService; @PostMapping(\"/add\") @ApiOperation(\"新增用户\") public Boolean add(@RequestBody UserAddDto dto)&#123; return userService.add(dto); &#125; /** * setter注入 * @param userService */ @Autowired public void setUserService(UserService userService) &#123; this.userService = userService; &#125;&#125; 至此新增功能就完成了，可以运行/调试SsmProjectApplication进入Api文档页面查看和调试接口了：（本项目端口号8888） 用户新增Api文档页 调试页 在调试页中，填入对应属性的值，点击发送后，在IDEA控制台能够看到具体的session信息，返回true后，进入数据库管理查看User表内容，能看到新增的用户数据记录。（后面的功能实现不再提供Api调试截图了） 用户修改实现逻辑和新增基本一致。 添加UserUpdateDto类1234567891011121314151617181920212223package com.ssm.ssmproject.system.entity.dto;@Data@ApiModel(value = \"UserUpdateDto对象\", description = \"用户修改Dto\")public class UserUpdateDto implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = \"用户唯一标识\") private Long id; @ApiModelProperty(value = \"用户名\") private String name; @ApiModelProperty(value = \"用户账号\") private String account; @ApiModelProperty(value = \"用户密码\") private String password; @ApiModelProperty(value = \"手机号\") private String tel;&#125; Service层添加业务逻辑UserService接口中添加方法： 123456/** * 修改用户 * @param dto * @return */Boolean update(UserUpdateDto dto); UserServiceImpl类中实现update方法： 1234567@Overridepublic Boolean update(UserUpdateDto dto)&#123; User user = new User(); BeanUtils.copyProperties(dto, user); return baseMapper.updateById(user) &gt; 0;&#125; Controller层实现接口12345@PostMapping(\"/update\")@ApiOperation(\"修改用户\")public Boolean update(@RequestBody UserUpdateDto dto)&#123; return userService.update(dto);&#125; 用户查询（by id）添加UserVo类在Entity包中新建vo包，添加User类对应的UserVo类：不显示用户密码 12345678910111213141516171819package com.ssm.ssmproject.system.entity.vo;@Data@ApiModel(value = \"UserVo对象\", description = \"用户信息Dto\")public class UserVo implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = \"用户名\") private String name; @ApiModelProperty(value = \"用户唯一标识\") private Long id; @ApiModelProperty(value = \"用户账号\") private String account; @ApiModelProperty(value = \"手机号\") private String tel;&#125; Controller层实现接口UserController类中添加方法： 12345678910@GetMapping(\"/info/&#123;id&#125;\")@ApiOperation(\"用户详情\")public UserVo info(@PathVariable Long id)&#123; User user = userService.getById(id); UserVo userVo = new UserVo(); BeanUtils.copyProperties(user, userVo); return userVo;&#125; 运行项目后，在Api调试页面发送刚才新建的用户id，可以返回对应的VO对象。 用户删除（by id）Controller层实现接口： 12345@DeleteMapping(\"/remove/&#123;id&#125;\")@ApiOperation(\"删除用户\")public Boolean remove(@PathVariable Long id)&#123; return userService.removeById(id);&#125; 同查询操作调试方法，只不过这里的数据库操作是删除操作。 本章小结至此，Mybatis-plus的最基础的配置就完成了，同时也熟悉了如何实现最基础的CRUD操作（没有进行任何校验）。其中Mybatis-plus的分页插件具体使用将在后面的文章中出现。 上一篇：SSM框架（后端）——（三）集成和配置swagger-bootstrap-ui(swagger2) 下一篇：","tags":[{"name":"ssm","slug":"ssm","permalink":"https://myharu.github.io/tags/ssm/"},{"name":"Mybatis-plus","slug":"Mybatis-plus","permalink":"https://myharu.github.io/tags/Mybatis-plus/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://myharu.github.io/tags/Mybatis/"}]},{"title":"SSM框架（后端）——（三）集成和配置swagger-bootstrap-ui(swagger2)","date":"2020-09-13T14:10:23.000Z","path":"2020/09/13/SSM框架（后端）——（三）集成和配置swagger-bootstrap-ui(swagger2)/","text":"注：本文直接参考官方文档 Maven中引入依赖Jar包pom.xml中添加依赖 123456&lt;!-- swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 然后引入SwaggerBootstrapUi的jar包（具体版本号可用最新的${lastVersion}） 123456&lt;!-- SwaggerBootstrapUi --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt; 这里需要注意，引入swagger2Api文档，需要项目支持web应用，因此需要导入spring-boot-starter-web依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写Swagger2Config配置文件添加SwaggerConfig类，配置如下： 12345678910111213141516171819202122@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //扫描所有注解的API .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"SSM Demo Project APIs\") .description(\"swagger-bootstrap-ui\") .version(\"1.0\") .build(); &#125;&#125; WebMvcConfigurer中注册资源SpringBoot中访问doc.html报404的解决办法：实现SpringBoot的WebMvcConfigurer接口，添加相关的ResourceHandler 123456789101112131415@Configuration@Slf4jpublic class WebmvcConfig implements WebMvcConfigurer &#123; /** * 注册资源 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"doc.html\").addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); &#125;&#125; 界面展示进入本地端口号网址，http://localhost:8888/doc.html（端口号在`application.properties`文件中设置），此时因为是空项目，没有任何接口显示。 Swagger常用注释说明及使用方法TODO 未完待写… 本章小结至此，项目通过Swagger2生成的API文档获得了，可以方便的查看接口和测试了。 上一篇：SSM框架（后端）——（二）配置MySQL数据库 下一篇：SSM框架（后端）——（四）集成和配置mybatis-plus","tags":[{"name":"ssm","slug":"ssm","permalink":"https://myharu.github.io/tags/ssm/"},{"name":"swagger2","slug":"swagger2","permalink":"https://myharu.github.io/tags/swagger2/"},{"name":"swagger-bootstrap-ui","slug":"swagger-bootstrap-ui","permalink":"https://myharu.github.io/tags/swagger-bootstrap-ui/"}]},{"title":"SSM框架（后端）——（二）配置MySQL数据库","date":"2020-09-13T01:49:58.000Z","path":"2020/09/13/SSM框架（后端）——（二）配置MySQL数据库/","text":"注：如果本地和IDEA的MySQL数据库连接已经配置好了，需要配置到SpringBoot项目中，请直接跳转至第四步。 MySQL数据库的安装下载MySQL Community版本MySQL Community 官方下载地址 下载对应操作系统的版本安装包。（笔者使用的Windows系统，下载了免安装的zip压缩包） 安装配置本地MySQL服务器官方安装教程文档 参考官方文档，根据具体的安装包和操作系统查看对应的安装教程。如果下载和笔者相同版本的免安装包，直接参考：Windows免安装zip IDEA连接MySQL数据库本地安装配置好MySQL服务以后，IDEA提供的非常简便的数据库连接和操作接口，不用再使用windows命令行或者其他第三方数据库管理软件来操作数据库了。 Database选项卡添加数据库打开IDEA和对应项目，在右侧边栏位置找到Database选项卡，点击添加按钮 选择MySQL数据库​ 端口号为默认，填入数据库的用户名和密码，选择需要的数据库test，完整的URL如下： 1jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=GMT%2B8&amp;allowMultiQueries=true ?后面为数据库配置信息，具体属性参考官方文档，使用中根据需求添加属性配置：MySQL连接配置属性参考文档 本项目中的数据库连接配置具体解释： useUnicode=true&amp;characterEncoding=UTF-8：因为MySQL原生不支持UTF-8字符集，因此需要特别注明； autoReconnect=true： If enabled the driver will throw an exception for a queries issued on a stale or dead connection, which belong to the current transaction, but will attempt reconnect before the next query issued on the connection in a new transaction. useSSL=false：不启用SSL，降低安全性，但是能提高查询效率； zeroDateTimeBehavior=convertToNull：在针对DATETIME值时，如果值为0000-00-00，转换为null；策略除了convertToNull，还有exception（默认）抛出异常和round替换为最近日期； serverTimezone=GMT%2B8：时区选择（其中+号在URL中被编码为%2B8）； allowMultiQueries=true：允许;间隔的查询语句，支持批量SQL语句（会影响到Mybatis的批量查询、更新等功能） 填写完成后可以点击Test Connection测试是否能连接上，测试完成后需要重新填写密码。这样就建立了IDEA和MySQL数据库的连接，可以在IDEA提供的数据库console中进行SQL操作，也可以很便捷地查看数据库结构。 创建demo数据库用户表作为demo案例，必然要通过整个框架进行数据操作，因此这里需要构建一个基本的数据库。为了方便起见，本文以简单的用户管理进行演示。具体用户表建立如下： 123456789101112131415161718DROP TABLE IF EXISTS user;create table user( name VARCHAR(32) null comment '用户名', id BIGINT auto_increment comment '用户唯一标识', account VARCHAR(32) not null comment '用户账号', password VARCHAR(32) not null comment '用户密码', created_at DATETIME null comment '创建时间', created_by BIGINT null comment '创建人id', updated_at DATETIME null comment '修改时间', updated_by BIGINT null comment '更新人id', deleted TINYINT default 0 null comment '逻辑删除 删除标志 0未删除 1已删除', status TINYINT default 1 null comment '账号状态 0禁用 1启用', tel VARCHAR(11) not null comment '手机号', remark VARCHAR(512) null comment '备注', constraint User_pk primary key (id))ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic comment '用户表'; 其中具体字段在后面的文章中会用到，到时再进行具体描述。（也可以根据自己的喜好创建表和字段）创建表后的配置信息，可以参考：Create-table官方文档 ENGINE = InnoDB：引擎选择InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci：字符集为UTF-8与连接时配置保持一致； ROW_FORMAT = Dynamic ：InnoDB提供的动态行格式，对于VARCHARVARBINARY和BLOB和TEXT类型存储可变长的列值 项目MySQL数据库配置虽然前面在IDEA连接了数据库，但是在项目中并没有做MySQL数据库的相关配置。Spring官方非常贴心的给出了连接MySQL数据库的示例，可以直接参考官方示例：官方示例 pom.xml中添加MySQL`依赖包12345&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; src/main/resources/application.properties`中添加数据库连接配置在刷新Maven依赖包导入项目后，在application.properties文件中添加数据库连接配置： 12345678server.port=8888spring.application.name=ssmDemospring.mvc.throw-exception-if-no-handler-found=truespring.resources.add-mappings=falsespring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ritai_mes_dev?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=GMT%2B8&amp;allowMultiQueries=truespring.datasource.username=rootspring.datasource.password=root 具体的属性配置请参考官方文档，这里不做详细介绍了。其中数据库连接URL中的配置，请参考数据库连接配置。 本章小结至此，项目和IDE都已经配置连接好了MySQL数据库。 上一篇：SSM框架（后端）——（一）初始化SpringBoot项目 下一篇：SSM框架（后端）——（三）集成和配置swagger-bootstrap-ui(swagger2)","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://myharu.github.io/tags/MySQL/"},{"name":"ssm","slug":"ssm","permalink":"https://myharu.github.io/tags/ssm/"}]},{"title":"SSM框架（后端）——（一）初始化SpringBoot项目","date":"2020-09-12T15:01:20.000Z","path":"2020/09/12/SSM框架（后端）——（一）初始化SpringBoot项目/","text":"Spring Initializer初始化项目Spring Initilalizer 是官方提供的初始化接口，可以直接通过网址进入：Spring Initializer 具体配置信息如图所示： 初始化SpringBoot项目，可以直接在上述网页中填写配置信息后，点击GENERATE按钮，会直接下载接口创建好的项目压缩包文件，下载到本地解压缩用IDEA打开项目即可。 其实IDEA直接提供了连接Spring Initilalizer生成初始化项目的接口，因此在IDEA中也能非常方便的构建项目。下面具体介绍一下IDEA中的构建操作。 新建Spring Initializer项目 填写项目基础配置信息Group、Artifact、Version、Description按照需要进行填写。 选择依赖包可按照需要选择需要的包（如果部分需求已经确定，比较方便），为了获取原始的初始化SpringBoot项目就暂不选择。 填写项目名称可根据需要修改项目名称。 生成初始化SpringBoot项目至此，一个空SpringBoot项目就生成了。 项目配置文档pom.xml自动生成的Maven配置文档pom.xml，具体Maven配置请参照官方文档（有时间学习完了写一篇） 这个文档主要用于项目开启后添加依赖包时进行配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm-project&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;ssm-project&lt;/name&gt; &lt;description&gt;SSM Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; src/main/resources/application.properties项目配置文档，初始化时为空。项目中主要用于一些基础配置：端口号、数据库连接等，具体用法查阅参考文档。 本章小结至此，一个完整的SpringBoot空项目已经在IDEA中生成了。 上一篇： 下一篇：SSM框架（后端）——（二）配置MySQL数据库","tags":[{"name":"ssm","slug":"ssm","permalink":"https://myharu.github.io/tags/ssm/"},{"name":"Spring","slug":"Spring","permalink":"https://myharu.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://myharu.github.io/tags/SpringBoot/"}]}]